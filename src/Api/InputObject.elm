-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.InputObject exposing (..)

import Api.Interface
import Api.Object
import Api.Scalar
import Api.ScalarCodecs
import Api.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildAvailableNetworkInput : AvailableNetworkInputRequiredFields -> AvailableNetworkInput
buildAvailableNetworkInput required =
    { name = required.name, rating = required.rating, description = required.description }


type alias AvailableNetworkInputRequiredFields =
    { name : String
    , rating : Int
    , description : String
    }


{-| Type for the AvailableNetworkInput input object.
-}
type alias AvailableNetworkInput =
    { name : String
    , rating : Int
    , description : String
    }


{-| Encode a AvailableNetworkInput into a value that can be used as an argument.
-}
encodeAvailableNetworkInput : AvailableNetworkInput -> Value
encodeAvailableNetworkInput input =
    Encode.maybeObject
        [ ( "name", Encode.string input.name |> Just ), ( "rating", Encode.int input.rating |> Just ), ( "description", Encode.string input.description |> Just ) ]


buildShowInput : ShowInputRequiredFields -> ShowInput
buildShowInput required =
    { name = required.name, rating = required.rating, description = required.description }


type alias ShowInputRequiredFields =
    { name : String
    , rating : Int
    , description : String
    }


{-| Type for the ShowInput input object.
-}
type alias ShowInput =
    { name : String
    , rating : Int
    , description : String
    }


{-| Encode a ShowInput into a value that can be used as an argument.
-}
encodeShowInput : ShowInput -> Value
encodeShowInput input =
    Encode.maybeObject
        [ ( "name", Encode.string input.name |> Just ), ( "rating", Encode.int input.rating |> Just ), ( "description", Encode.string input.description |> Just ) ]


buildUserInput : UserInputRequiredFields -> (UserInputOptionalFields -> UserInputOptionalFields) -> UserInput
buildUserInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { network = Absent, amount = Absent, start = Absent, end = Absent, shows = Absent }
    in
    { username = required.username, walletAddress = required.walletAddress, network = optionals.network, amount = optionals.amount, start = optionals.start, end = optionals.end, shows = optionals.shows }


type alias UserInputRequiredFields =
    { username : Api.ScalarCodecs.Id
    , walletAddress : String
    }


type alias UserInputOptionalFields =
    { network : OptionalArgument String
    , amount : OptionalArgument Int
    , start : OptionalArgument Api.ScalarCodecs.Date
    , end : OptionalArgument Api.ScalarCodecs.Date
    , shows : OptionalArgument (List ShowInput)
    }


{-| Type for the UserInput input object.
-}
type alias UserInput =
    { username : Api.ScalarCodecs.Id
    , walletAddress : String
    , network : OptionalArgument String
    , amount : OptionalArgument Int
    , start : OptionalArgument Api.ScalarCodecs.Date
    , end : OptionalArgument Api.ScalarCodecs.Date
    , shows : OptionalArgument (List ShowInput)
    }


{-| Encode a UserInput into a value that can be used as an argument.
-}
encodeUserInput : UserInput -> Value
encodeUserInput input =
    Encode.maybeObject
        [ ( "username", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) input.username |> Just ), ( "walletAddress", Encode.string input.walletAddress |> Just ), ( "network", Encode.string |> Encode.optional input.network ), ( "amount", Encode.int |> Encode.optional input.amount ), ( "start", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.start ), ( "end", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDate) |> Encode.optional input.end ), ( "shows", (encodeShowInput |> Encode.list) |> Encode.optional input.shows ) ]
